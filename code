import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from PIL import Image

import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from sklearn.model_selection import train_test_split
from sklearn.utils.class_weight import compute_class_weight
from sklearn.metrics import classification_report, confusion_matrix

# Dataset path
root_dir = r"path to the images"

# Collect image paths and labels
data = []
for label in os.listdir(root_dir):
    label_path = os.path.join(root_dir, label)
    if os.path.isdir(label_path):
        for img_file in os.listdir(label_path):
            if img_file.lower().endswith(('.jpg', '.jpeg', '.png')):
                data.append({
                    'filename': os.path.join(label, img_file),
                    'label': label
                })

df = pd.DataFrame(data)
df.to_csv('image_labels.csv', index=False)

train_df, test_df = train_test_split(df, test_size=0.2, stratify=df['label'], random_state=42)
train_df, val_df = train_test_split(train_df, test_size=0.25, stratify=train_df['label'], random_state=42)

# --- 2. Data Generators ---
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=30,
    width_shift_range=0.3,
    height_shift_range=0.3,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

val_test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_dataframe(
    train_df, root_dir, x_col='filename', y_col='label',
    target_size=(224, 224), batch_size=32, class_mode='categorical', shuffle=True
)

val_generator = val_test_datagen.flow_from_dataframe(
    val_df, root_dir, x_col='filename', y_col='label',
    target_size=(224, 224), batch_size=32, class_mode='categorical', shuffle=True
)

test_generator = val_test_datagen.flow_from_dataframe(
    test_df, root_dir, x_col='filename', y_col='label',
    target_size=(224, 224), batch_size=32, class_mode='categorical', shuffle=False
)


# --- 3. Compute Class Weights ---
labels = train_generator.classes
class_weights = compute_class_weight(
    class_weight='balanced',
    classes=np.unique(labels),
    y=labels
)
class_weight_dict = dict(enumerate(class_weights))
print("Class Weights:", class_weight_dict)


# --- 4. Build the Model ---
base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
base_model.trainable = True


# Fine-tune deeper layers
for layer in base_model.layers[:-50]:
    layer.trainable = False

x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(128, activation='relu')(x)
x = Dropout(0.5)(x)
predictions = Dense(4, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=predictions)

model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=1e-4),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

model.summary()


# --- 5. Callbacks ---
early_stop = tf.keras.callbacks.EarlyStopping(patience=5, restore_best_weights=True)
reduce_lr = tf.keras.callbacks.ReduceLROnPlateau(factor=0.2, patience=2)


# --- 6. Train the Model ---
history = model.fit(
    train_generator,
    epochs=30,
    validation_data=val_generator,
    class_weight=class_weight_dict,
    callbacks=[early_stop, reduce_lr]
)

model.save("Project_1_Alzhiemers.keras")  # Saves in Keras format


# --- 7. Evaluation ---
y_pred_probs = model.predict(test_generator)
y_pred = np.argmax(y_pred_probs, axis=1)
y_true = test_generator.classes
class_names = list(test_generator.class_indices.keys())

print("\nClassification Report:")
print(classification_report(y_true, y_pred, target_names=class_names))



# Confusion Matrix
cm = confusion_matrix(y_true, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=class_names, yticklabels=class_names)
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()


# --- 8. Quick Sample Predictions ---
x_test, y_sample_true = test_generator[0]
y_sample_pred = model.predict(x_test)

for i in range(3):
    pred_class = class_names[np.argmax(y_sample_pred[i])]
    true_class = class_names[np.argmax(y_sample_true[i])]
    plt.imshow(x_test[i])
    plt.title(f"Predicted: {pred_class}, Actual: {true_class}")
    plt.axis('off')
    plt.show()


import cv2
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing.image import img_to_array, load_img

# Load the trained model
model = load_model("Project_1_Alzhiemers.keras")
class_names = ['MildDemented', 'ModerateDemented', 'NonDemented', 'VeryMildDemented']

# Function to preprocess input image
def preprocess_image(img_path, target_size=(224, 224)):
    img = load_img(img_path, target_size=target_size)
    img_array = img_to_array(img) / 255.0
    return np.expand_dims(img_array, axis=0), img


# Grad-CAM function
def generate_gradcam(model, img_array, class_index, layer_name='Conv_1'):
    grad_model = tf.keras.models.Model(
        [model.inputs],
        [model.get_layer(layer_name).output, model.output]
    )

    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        loss = predictions[:, class_index]

    grads = tape.gradient(loss, conv_outputs)[0]
    conv_outputs = conv_outputs[0]
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1))

    # Multiply and create heatmap
    heatmap = conv_outputs @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)
    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    heatmap = heatmap.numpy()

    return heatmap



# Function to overlay heatmap on image
def display_gradcam(img_path):
    img_array, orig_img = preprocess_image(img_path)
    preds = model.predict(img_array)
    pred_index = np.argmax(preds[0])
    class_label = class_names[pred_index]

    heatmap = generate_gradcam(model, img_array, pred_index)
    heatmap = cv2.resize(heatmap, (orig_img.size[0], orig_img.size[1]))
    heatmap = np.uint8(255 * heatmap)
    heatmap_color = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
      # Convert original PIL image to array
    orig_img_array = np.array(orig_img)
    overlay = cv2.addWeighted(orig_img_array, 0.6, heatmap_color, 0.4, 0)
     # Display
    plt.imshow(overlay)
    plt.title(f"Predicted: {class_label}")
    plt.axis('off')
    plt.show()



img_path = "F://Alzhiemers//combined_images//NonDemented//00db23c3-2024-4ce0-807c-8f4be2ce2d75.jpg"  # Change this
display_gradcam(img_path)




